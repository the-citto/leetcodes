import typing
from collections.abc import Callable

from google_benchmark._benchmark import BigO as BigO
from google_benchmark._benchmark import Counter as Counter
from google_benchmark._benchmark import State as State
from google_benchmark._benchmark import TimeUnit as TimeUnit
from google_benchmark._benchmark import kMicrosecond as kMicrosecond
from google_benchmark._benchmark import kMillisecond as kMillisecond
from google_benchmark._benchmark import kNanosecond as kNanosecond
from google_benchmark._benchmark import kSecond as kSecond
from google_benchmark._benchmark import o1 as o1
from google_benchmark._benchmark import oAuto as oAuto
from google_benchmark._benchmark import oLambda as oLambda
from google_benchmark._benchmark import oLogN as oLogN
from google_benchmark._benchmark import oN as oN
from google_benchmark._benchmark import oNCubed as oNCubed
from google_benchmark._benchmark import oNLogN as oNLogN
from google_benchmark._benchmark import oNone as oNone
from google_benchmark._benchmark import oNSquared as oNSquared

class __OptionMaker:
    class Options:
        func: Callable[..., typing.Any]
        builder_calls: list[tuple[str, tuple[typing.Any, ...], dict[str, typing.Any]]]
        def __init__(self, func: Callable[..., typing.Any]) -> None: ...

    @classmethod
    def make(cls, func_or_options: Callable[..., typing.Any] | Options) -> Options: ...
    def __getattr__(self, name: str) -> Callable[..., Callable[[Callable[..., typing.Any] | Options], Options]]: ...
    def unit(self, arg: TimeUnit, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def arg(self, arg: int, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def args(self, arg: typing.Sequence[int], /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def range(self, start: int, limit: int) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def dense_range(
        self,
        start: int,
        limit: int,
        step: int = 1,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def ranges(
        self,
        arg: typing.Sequence[tuple[int, int]],
        /,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def args_product(
        self,
        arg: typing.Sequence[typing.Sequence[int]],
        /,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def arg_name(self, arg: str, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def arg_names(self, arg: typing.Sequence[str], /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def range_pair(
        self,
        lo1: int,
        hi1: int,
        lo2: int,
        hi2: int,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def range_multiplier(self, arg: int, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def min_time(self, arg: float, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def min_warmup_time(self, arg: float, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def iterations(self, arg: int, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def repetitions(self, arg: int, /) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def report_aggregates_only(
        self,
        value: bool = True,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def display_aggregates_only(
        self,
        value: bool = True,
    ) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def measure_process_cpu_time(self) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def use_real_time(self) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def use_manual_time(self) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...
    def complexity(self, complexity: BigO = ...) -> Callable[[Callable[..., typing.Any] | Options], Options]: ...

option: __OptionMaker

def register[T](f: T | None = None) -> T | Callable[[T], T]: ...
def main(argv: list[str] | None = None) -> None: ...
